# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave

from buildbot_configuration import slave_list

c['slaves'] = [BuildSlave(slave_name, "dev", **slave_args) for slave_name, slave_args in slave_list]

# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = 9989

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.


from buildbot_configuration import master_repo_url, slave_repo_url, slave_list
from buildbot_configuration import target_branches, target_builds
from buildbot_configuration import integration_result_dir

from buildbot.changes.gitpoller import GitPoller
c['change_source'] = []
c['change_source'].append(GitPoller(
        master_repo_url,
        workdir='gitpoller_rosetta_dev', branches=target_branches.keys(),
        pollinterval=60))

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  

from buildbot.schedulers.basic import AnyBranchScheduler, SingleBranchScheduler
from buildbot.schedulers.forcesched import ForceScheduler, StringParameter, ChoiceStringParameter, FixedParameter
from buildbot.changes import filter

c['schedulers'] = []

for b, config in target_branches.items():
  for build_type in target_builds:

    c['schedulers'].append(AnyBranchScheduler(
                                name="%s_%s" % (b, build_type),
                                change_filter=filter.ChangeFilter(branch=b),
                                treeStableTimer=10,
                                builderNames=["%s_%s" % (b, build_type)],
                                properties = {
                                  "build_extras" : config["extras"],
                                  "integration_result_dir" : integration_result_dir
                                }))

    c['schedulers'].append(ForceScheduler(
                                name="force_%s_%s" % (b, build_type),
                                branch=FixedParameter(name="branch", default=b),
                                project=FixedParameter(name="project", default=""),
                                repository=FixedParameter(name="repository", default=""),
                                builderNames=["%s_%s" % (b, build_type)],
                                properties = [
                                  FixedParameter(name="build_extras", default=config["extras"] if config["extras"] else ""),
                                  FixedParameter(name="integration_result_dir", default=integration_result_dir)]
                                ))

c['schedulers'].append(ForceScheduler(
                            name="force_build",
                            builderNames=["build_manual"],
                           properties=[
                             ChoiceStringParameter(
                               name="build_mode",
                               label="build_mode:<br>",
                               choices=["release","debug", "release_debug"], default="release_debug"),
                             StringParameter(
                               name="build_extras",
                               label="build_extras:<br>",
                               default="", size=80),
                             StringParameter(
                               name="integration_result_dir",
                               label="Integration test drop directory:<br>",
                               defualt=integration_result_dir, size=80)
                            ]))


def mergeRequests(builder, req1, req2):
  "Any requests with the same branch can be merged."
  return req1.source.branch == req2.source.branch

c['mergeRequests'] = mergeRequests

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand
from buildbot.process.properties import WithProperties
from buildbot.process.properties import Interpolate, Property


release_factory = BuildFactory()

from test_support import UnitTest, IntegrationTest
from build_support import SconsCompile

full_build_factory = BuildFactory()

from buildbot_configuration import slave_repo_url

# check out the source
full_build_factory.addStep(
    Git(
      repourl=slave_repo_url, mode='incremental', workdir="main", branch=Interpolate("%(src::branch)s")
      ))

# Insert build options into sconscript
full_build_factory.addStep(
    ShellCommand(
      command='echo "SetOption(\'implicit_cache\', 1);Decider(\'MD5-timestamp\')" >> SConscript',
      workdir="main/source",
      haltOnFailure=True,
      description="configure", descriptionSuffix="SConscript"))


# build for unit tests
full_build_factory.addStep(
    SconsCompile(
      jobs=20,
      workdir="main/source",
      haltOnFailure=True,
      description="compiling"))

full_build_factory.addStep(
    SconsCompile(
      build_cat="test",
      jobs=20,
      workdir="main/source",
      haltOnFailure=True,
      description="compiling", descriptionSuffix="tests"))

full_build_factory.addStep(
    UnitTest(
      verbose=True,
      jobs=20,
      workdir="main/source",
      flunkOnFailure=True,
      description="testing", descriptionSuffix="unit"))

full_build_factory.addStep(
    SconsCompile(
      build_target = "bin",
      jobs=20,
      workdir="main/source",
      haltOnFailure=True,
      description="compiling", descriptionSuffix="bin"))


full_build_factory.addStep(
    ShellCommand(
      command=["rm", "-rf", "ref", "new"],
      workdir="main/tests/integration",
      description="clean", descriptionSuffix="integration"))

full_build_factory.addStep(
    IntegrationTest(
      jobs=20,
      workdir="main/tests/integration",
      flunkOnFailure=True,
      description="run", descriptionSuffix="integration"))

full_build_factory.addStep(
    ShellCommand(
      command=["mv", "-f", "ref", Interpolate("%(prop:integration_result_dir)s/%(src::branch)s_%(src::revision)s_%(prop:build_mode)s")],
      workdir="main/tests/integration",
      description="save", descriptionSuffix="integration"))
full_build_factory.addStep(
    ShellCommand(
      command=["ln", "-s", "-f", Interpolate("%(src::branch)s_%(src::revision)s_%(prop:build_mode)s"), Interpolate("%(prop:integration_result_dir)s/%(src::branch)s_%(prop:build_mode)s")],
      workdir="main/tests/integration",
      description="save", descriptionSuffix="integration"))

from buildbot.config import BuilderConfig
c['builders'] = []

for build_type in target_builds:
  for branch in target_branches.keys():
    c['builders'].append(
        BuilderConfig(
          name="%s_%s" % (branch, build_type),
          slavenames=[slave_name for slave_name, _ in slave_list],
          builddir = "%s_%s" % (branch, build_type),
          factory=full_build_factory,
          properties={"build_mode" : build_type}))

c['builders'].append(
    BuilderConfig(name="build_manual",
      slavenames=[slave_name for slave_name, _ in slave_list],
      factory=full_build_factory))

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
from buildbot.status.web import authz, auth
from buildbot.status.mail import MailNotifier

mn = MailNotifier(fromaddr="fordas@uw.edu", sendToInterestedUsers=False, extraRecipients=['fordas@uw.edu'])
c["status"].append(mn)

authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    auth=auth.BasicAuth([("fordas","dev")]),
    gracefulShutdown = True,
    forceBuild = 'full_build', # use this to test your slave once it is set up
    forceAllBuilds = True,
    pingBuilder = True,
    stopBuild = True,
    stopAllBuilds = True,
    cancelPendingBuild = True,
)

c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg, order_console_by_time=True))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "/work/asford/workspace/rosetta_dev"
c['titleURL'] = "https://github.com/RosettaCommons/main"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

import socket

c['buildbotURL'] = "http://dig18:8010/"

####### DB URL

c['db'] = {
    # This specifies what database buildbot uses to store its state.  You can leave
    # this at its default for all but the largest installations.
    'db_url' : "sqlite:///state.sqlite",
}
